
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>jira-graph-viz</title>
        <script type="text/javascript" src="{{ url_for('static', filename= 'd3.min.js' )}}"></script>
        <style type="text/css">      
        </style>
    </head>
    <body>
    	<h2>jira-graph-viz</h2>
        <form action="" method="post">
        	{{ form.hidden_tag() }}
        	<p>
        		{{ form.query.label }}<br>
        		{{ form.query(size=100) }}
        	</p>
        	<p>
        		{{ form.submit() }}
        	</p>

        </form>
        <br>
        
        
        {% with messages = get_flashed_messages() %}
        {% if messages %}
        <ul>
            {% for message in messages %}
            <li>{{ message }}</li>
            {% endfor %}
        </ul>
        {% endif %}
        {% endwith %}
        <br>
        <hr>

        <form>
            <input type="radio" name="allLinks" value="query" id="queryTicketsOnly" checked>Show only tickets in query</input><br>
            <input type="radio" name="allLinks" value="all" id="allLinkedTickets">Show all linked tickets</input>
        </form>
        
        
   
        <script type="text/javascript">
			

        
            var dataset = new Set({{ dataset | tojson }});
            
            var links = new Set({{ links | tojson }});

           
            var querySet = new Set({{ query_list | tojson }});

            var nodeSet = new Set(querySet);

            

            const width = window.innerWidth;
            const height = 400 + querySet.size * 15;
            const baseUrl = 'https://elsevier-healthsolutions.atlassian.net/browse/';

            const STATUSCOLORS = {
                "To Do": "#8e8e93", //grey
                "Icebox": "aqua",
                "In Progress": "#ffcc00", //yellow
                "Code Review": "orange",
                "Blocked": "red",
                "Testing Failed": "purple",
                "Ready for Testing": "#007aff", //dark blue
                "Ready for Acceptance": "#009F6B", //dark green
                "Done": "#4cd964", // green
                "Testing Passed": "#4cd964", // green
            }

            const LINKCOLORS = {
                "Relates": "green", 
                "Related": "green", 
                "Dependency": "orange", 
                "Blocks": "red",
                "Bonfire Testing": "purple",
                "Issue Split": "#007aff", //dark blue
                "Cloners": "#5ac8fa", //light blue
                "subtask": "black"
            }

            const KEYTEXTOFFSET = {
                    "Epic": 55,
                    "Story": 45,
                    "Technical Story": 45,
                    "Bug": 35,
                    "QA Test Case": 25
            }

            const NODERADIUS = {
                    "Epic": 40,
                    "Story": 30,
                    "Technical Story": 30,
                    "Bug": 20,
                    "QA Test Case": 10
                }

            var legendSVG = d3.select('body').append('svg').attr('width', width).attr('height', 250)
                            .append('circle').attr('cx', 20).attr('cy', 20).attr('r', 10).attr('fill', STATUSCOLORS["To Do"])
                            .append('text').attr('font-size', 15).attr('dx',40).attr('dy', 20).text('To Do')

            var svg = d3.select('body').append('svg').attr('width', width).attr('height', height),
                nodeLink = svg.append("g").attr('class', 'nodeLinks').selectAll('line'),
                node = svg.append('g').attr('class', 'nodes').selectAll('circle'),
                keyLink = svg.append('g').attr('class', 'keyLinks').selectAll('a');


                            
        

            var linkForce = d3.forceLink()
                  .id(function (link) { return link.key })
                  .strength(.25);

            var simulation = d3.forceSimulation()
                  .force('link', linkForce)
                  .force('charge', d3.forceManyBody().strength(-150)) 
                  .force('center', d3.forceCenter(width / 2, height / 2))
                  .force('x', d3.forceX())
                  .force('y', d3.forceY())
                  .force('collision', d3.forceCollide().radius(45))
                  .on('tick', ticked);


            var dragDrop = d3.drag().on('start', function (node) {
                  node.fx = node.x
                  node.fy = node.y
                }).on('drag', function (node) {
                  simulation.alphaTarget(0.6).restart()
                  node.fx = d3.event.x
                  node.fy = d3.event.y
                }).on('end', function (node) {
                  if (!d3.event.active) {
                    simulation.alphaTarget(0)
                  }
                  node.fx = null
                  node.fy = null
                });

            update();              

            document.getElementById("allLinkedTickets").addEventListener("click", function() {
                var toAddtoDataset = new Set();
                    
                    console.log("showAllLinkedTickets");

                    [...dataset].forEach(issue => {
                        //if this is an issue from the original query (and thus has issuelinks field)
                        if ("issuelinks" in issue) {  
                            issue.issuelinks.forEach(linkedIssue => {
                                if (!nodeSet.has(linkedIssue.key)) {
                                linkedIssue['addedBy'] = issue.key;
                                toAddtoDataset.add(linkedIssue);
                                //console.log(linkedIssue);
                                nodeSet.add(linkedIssue.key);
                                //add links to links
                                links.add({
                                'addedBy': issue.key,
                                'source': issue.key,
                                'target': linkedIssue.key,
                                'type': linkedIssue.type
                                });
                                
                            }

                            });
                        }    
                    });
                    
                    [...toAddtoDataset].forEach(linkedIssue => {
                        dataset.add(linkedIssue);
                    })
                    d3.selectAll('circle').classed('clicked', true);
                    console.log("adding all linked tickets");
                    console.log("nodeSet size: " + nodeSet.size);
                    console.log("querySet size: " + querySet.size);
                    console.log("links size: " + links.size);
                    console.log("dataset size: " + dataset.size);
                    console.log("nodeSet: " + [...nodeSet].toString());
                update();
            });
            document.getElementById("queryTicketsOnly").addEventListener("click", function() {
                nodeSet.forEach(key => {
                    if (!querySet.has(key)) {
                        nodeSet.delete(key);
                    }
                });
                
                dataset.forEach((ticket, j) => {
                    if ('addedBy' in ticket) {
                        // console.log(ticket);
                        dataset.delete(ticket);
                    }
                });
               
                links.forEach((link, k) => {
                    if ('addedBy' in link && link.addedBy != 'query') {
                        links.delete(link);
                    }
                });
                d3.selectAll('circle').classed('clicked', false);
                console.log("deleting all linked tickets outside of query");
                console.log("nodeSet size: " + nodeSet.size);
                console.log("querySet size: " + querySet.size);
                console.log("links size: " + links.size);
                console.log("dataset size: " + dataset.size);
                console.log("nodeSet: " + [...nodeSet].toString());

                update();
            });
            
            function update() {

                node = node.data([...dataset], d => d.key);
                node.exit().remove();
                node = node.enter()
                .append('circle')
                .attr('r', getRadiusFromTicketType)
                .attr('fill', getNodeColorFromStatus)
                .attr('stroke', getStrokeColor)
                .attr('stroke-width', 3)
                .merge(node)
                .call(dragDrop)
                .on('mouseover', handleMouseOver)
                .on('mouseout', handleMouseOut)
                .on('click', handleClick);
                

                nodeLink = nodeLink.data([...links], d => d.source + ' ' + d.target);
                nodeLink.exit().remove();
                nodeLink = nodeLink.enter()
                .append("line")
                .attr("stroke-width", 3)
                .attr("stroke", getLineColorFromLinkType)
                .attr("stroke-dasharray", [5,4])
                .attr("opacity", .8)
                .merge(nodeLink);

                keyLink = keyLink.data([...dataset], d => d.key);
                keyLink.exit().remove();
                keyLink = keyLink.enter()
                .append('a')
                .attr('href', function(d) { return baseUrl + d.key})
                .attr('target', '_blank')
                .append('text')
                .text(node => node.key)
                .attr('font-size', 15)
                .attr('dx', -20)
                .attr('dy', getKeyTextOffsetFromTicketType)
                .style('cursor', 'pointer')
                .merge(keyLink);

                nestedKeyText = svg.selectAll('text');

                simulation.nodes([...dataset])
                simulation.force('link').links([...links]);
                simulation.alpha(.8).restart();                
            }
            
            function getKeyTextOffsetFromTicketType(d) {
                if (d.issuetype in KEYTEXTOFFSET) return KEYTEXTOFFSET[d.issuetype];
                else return 25;

            }

            function getRadiusFromTicketType(d) {
                if (d.issuetype in NODERADIUS) return NODERADIUS[d.issuetype];
                else return 10;

            }

            function handleClick(d, i) {
                //get links from d
                var issuelinks = d.issuelinks;
                var issueAdded = false;
                //if node has not already been clicked
                if (!d3.select(this).classed('clicked') && 'issuelinks' in d) {             
                    issuelinks.forEach(issue => {
                        if (!nodeSet.has(issue.key)) {
                            issue['addedBy'] = d.key;
                            issue['x'] = d.x;
                            issue['y'] = d.y;
                            dataset.add(issue);
                            //console.log(issue);
                            nodeSet.add(issue.key);
                            //add links to links
                            links.add({
                            'addedBy': d.key,
                            'source': d.key,
                            'target': issue.key,
                            'type': issue.type
                            });
                            //set bool
                            issueAdded = true;
                        }
                    });                    
                    

                    if (issueAdded) {
                        d.fx = d.x;
                        d.fy = d.y;
                    }
                    console.log("adding linked tickets of clicked ticket");
                    console.log("nodeSet size: " + nodeSet.size);
                    console.log("querySet size: " + querySet.size);
                    console.log("links size: " + links.size);
                    console.log("dataset size: " + dataset.size);
                    console.log("nodeSet: " + [...nodeSet].toString());

                }
                else if (d3.select(this).classed('clicked') && 'issuelinks' in d) {
                    console.log("entering delete links control")
                    issuelinks.forEach(issue => {
                        if (!querySet.has(issue.key)) {
                            nodeSet.delete(issue.key);
                        }
                    });
                    
                    dataset.forEach((ticket, j) => {
                        if ('addedBy' in ticket && ticket.addedBy === d.key) {
                            // console.log(ticket);
                            dataset.delete(ticket);
                        }
                        //else if ('addedBy' in ticket) console.log(ticket);
                    });
                   
                    links.forEach((link, k) => {
                        if ('addedBy' in link && link.addedBy == d.key) {
                            links.delete(link);
                        }
                    });
                    

                    //unfix clicked node
                    d.fx = null;
                    d.fy = null;

                    console.log("deleting linked tickets of clicked ticket");
                    console.log("nodeSet size: " + nodeSet.size);
                    console.log("querySet size: " + querySet.size);
                    console.log("links size: " + links.size);
                    console.log("dataset size: " + dataset.size);
                    console.log("nodeSet: " + [...nodeSet].toString());
                }
                //toggle class = 'clicked'
                d3.select(this).classed('clicked', !d3.select(this).classed('clicked'));
                update();
            }
                
            function handleMouseOver(d, i) {
                d3.select(this).attr('fill', 'orange');
            }
            

            function handleMouseOut(d, i) {
                d3.select(this).attr('fill', getNodeColorFromStatus);
            }

            function getStrokeColor(d) {
                if (querySet.has(d.key)) return "black";
                else return getNodeColorFromStatus;
            }

            function getNodeColorFromStatus(node) {
              if (node.status in STATUSCOLORS) return STATUSCOLORS[node.status];
              else return "grey";
            }

            function getLineColorFromLinkType(link) {
              if (link.type in LINKCOLORS) return LINKCOLORS[link.type];
              else return "black";    
            }

            function ticked() {
                node
                    .attr('cx', function (node) { return node.x })
                    .attr('cy', function (node) { return node.y });
                nestedKeyText
                    .attr('x', function (node) { return node.x })
                    .attr('y', function (node) { return node.y });
                nodeLink
                    .attr('x1', function (link) { return link.source.x })
                    .attr('y1', function (link) { return link.source.y })
                    .attr('x2', function (link) { return link.target.x })
                    .attr('y2', function (link) { return link.target.y });
            }


        </script>
    </body>
</html>