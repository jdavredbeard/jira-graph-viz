
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>jira-graph-viz</title>
        <script src="https://d3js.org/d3.v5.min.js"></script>
        <style>
            div.tooltip {
                position: absolute;
                text-align: left;
                width: 400px;
                padding: 4px;
                font: 20px sans-serif;
                background: lightsteelblue;
                border: 0px;
                border-radius: 8px;
                pointer-events: none;
            }
        </style>
    </head>
    <body>
    	<h2>jira-graph-viz</h2>
        <form action="" method="post">
        	{{ form.hidden_tag() }}
        	<p>
        		{{ form.query.label }}<br>
        		{{ form.query(size=100) }}
        	</p>
        	<p>
        		{{ form.submit() }}
        	</p>

        </form>
        <br>
        
        
        {% with messages = get_flashed_messages() %}
        {% if messages %}
        <ul>
            {% for message in messages %}
            <li>{{ message }}</li>
            {% endfor %}
        </ul>
        {% endif %}
        {% endwith %}
        <br>
        <hr>

        <form>
            <input type="radio" name="allLinks" value="query" id="queryTicketsOnly" checked>Show only tickets in query</input><br>
            <input type="radio" name="allLinks" value="all" id="allLinkedTickets">Show all linked tickets</input>
        </form>
   
        <script type="text/javascript">

            // Data from backend call to Jira api is inserted here through templating - do not modify.
			
            var dataset = new Set({{ dataset | tojson }});
            var links = new Set({{ links | tojson }});
            var querySet = new Set({{ query_list | tojson }});
            var nodeSet = new Set(querySet);

            // .....
            // BEGIN CONSTANTS SECTION
            // .....

            // Feel free to add to or modify these to suite your needs.
            // If a node has property data that is not represented in these constants objects,
            // they will be given default values.

            // Defines the size of the svg that displays the visualization.
            const height = 1600 + querySet.size * 5;
            const width = 1600 + querySet.size * 5;

            // Defines the base url for the links to the tickets represented by the nodes.
            const baseUrl = 'https://elsevier-healthsolutions.atlassian.net/browse/';

            // Defines the colors of the nodes based on their status
            const STATUSCOLORS = {
                "Draft": "#E8E8E8", //light grey
                "To Do": "#8e8e93", //grey
                "Icebox": "aqua",
                "In Progress": "#ffcc00", //yellow
                "Code Review": "#ff8300", //bright orange
                "Blocked": "red",
                "Testing Failed": "purple",
                "Ready for Testing": "#007aff", //dark blue
                "Ready for Acceptance": "#0D98BA", //blue-green
                "Ready for Production": "#0D98BA", //blue-green
                "Ready for Release": "#0D98BA", //blue-green
                "Ready to Deploy": "#0D98BA", //blue-green
                "Done": "#4cd964", // green
                "Testing Passed": "#4cd964", // green
                "Released": "#4cd964", //green
                "Completed": "#4cd964", //green
                "Complete": "#4cd964", //green
            }

            // Defines the radius of the ring to which nodes with a given status are attracted in
            // the force simulation.

            const RADIALFORCERADIUS = {
                "Draft": 0,
                "To Do": height * 0.05,
                "Icebox": height * 0.3,
                "In Progress": height * 0.1,
                "Code Review": height * 0.1,
                "Blocked": 0,
                "Testing Failed": 0,
                "Ready for Testing": height * 0.15,
                "Ready for Acceptance": height * 0.2,
                "Ready for Production": height * 0.2,
                "Ready for Release": height * 0.2,
                "Ready to Deploy": height * 0.2,
                "Done": height * 0.25, // green
                "Testing Passed": height * 0.25, // green
                "Released": height * 0.25, //green
                "Completed": height * 0.25, //green
                "Complete": height   * 0.25, //green
            }

            // Defines the color of the lines between nodes, representing the type of link or relationship
            // between them.

            const LINKCOLORS = {
                "Relates": "green",
                "Related": "green",
                "Dependency": "orange",
                "Blocks": "red",
                "Bonfire Testing": "purple", // bonfire testing = discovered while testing
                "Issue Split": "#007aff", // dark blue
                "Cloners": "#5ac8fa", // light blue
                "subtask": "black",
                "parent": "black"
            }

            // Defines the radius of the node representing tickets given a certain ticket type.

            const NODERADIUS = {
                    "Epic": 40,
                    "Story": 25,
                    "Technical Story": 25,
                    "Content": 25,
                    "Design": 25,
                    "QA Task": 25,
                    "Bug": 15,
                    "Sub-task": 10,
                    "QA Test Case": 5,
                    "Task": 25
                }

            // .....
            // END CONSTANTS SECTION
            // .....

            var svg = d3.select('body').append('svg').attr('width', width).attr('height', height),
                nodeLink = svg.append("g").attr('class', 'nodeLinks').selectAll('line'),
                node = svg.append('g').attr('class', 'nodes').selectAll('circle'),
                keyLink = svg.append('g').attr('class', 'keyLinks').selectAll('a');

            // Define the div for the tooltip
            var div = d3.select("body").append("div")   
                .attr("class", "tooltip")               
                .style("opacity", 0);

            var linkForce = d3.forceLink()
                  .id(function (link) { return link.key })

            var simulation = d3.forceSimulation()
                  .force('link', linkForce)
                  .force('charge', d3.forceManyBody().strength(-1000)) 
                  .force('center', d3.forceCenter(width / 2, height / 2))
                  .force('x', d3.forceX())
                  .force('y', d3.forceY())
                  .force('collision', d3.forceCollide().radius(d => Math.min(NODERADIUS[d.issuetype] * 6, 45)))
                  .force('radial', d3.forceRadial(getRadialForceRadiusFromTicketStatus, width / 2, height / 2).strength(.5))
                  .on('tick', ticked);

            var dragDrop = d3.drag().on('start', function (node) {
                  node.fx = node.x
                  node.fy = node.y
                }).on('drag', function (node) {
                  simulation.alphaTarget(0.6).restart()
                  node.fx = d3.event.x
                  node.fy = d3.event.y
                }).on('end', function (node) {
                  if (!d3.event.active) {
                    simulation.alphaTarget(0)
                  }
                  node.fx = null
                  node.fy = null
                });

            update();              

            document.getElementById("allLinkedTickets").addEventListener("click", function() {
                var toAddtoDataset = new Set();
                    
                    console.log("showAllLinkedTickets");

                    [...dataset].forEach(issue => {
                        //if this is an issue from the original query (and thus has issuelinks field)
                        if ("issuelinks" in issue) {  
                            issue.issuelinks.forEach(linkedIssue => {
                                if (!nodeSet.has(linkedIssue.key)) {
                                    linkedIssue['addedBy'] = issue.key;
                                    toAddtoDataset.add(linkedIssue);
                                    nodeSet.add(linkedIssue.key);
                                }

                                links.add({
                                'addedBy': issue.key,
                                'source': issue.key,
                                'target': linkedIssue.key,
                                'type': linkedIssue.type
                                });
                            });
                        }    
                    });
                    
                    [...toAddtoDataset].forEach(linkedIssue => {
                        dataset.add(linkedIssue);
                    })
                    d3.selectAll('circle').classed('clicked', true);
                    console.log("adding all linked tickets");
                    console.log("nodeSet size: " + nodeSet.size);
                    console.log("querySet size: " + querySet.size);
                    console.log("links size: " + links.size);
                    console.log("dataset size: " + dataset.size);
                    console.log("nodeSet: " + [...nodeSet].toString());
                update();
            });
            
            document.getElementById("queryTicketsOnly").addEventListener("click", function() {
                nodeSet.forEach(key => {
                    if (!querySet.has(key)) {
                        nodeSet.delete(key);
                    }
                });
                
                dataset.forEach((ticket, j) => {
                    if ('addedBy' in ticket) {
                        dataset.delete(ticket);
                    }
                });
               
                links.forEach((link, k) => {
                    if ('addedBy' in link && link.addedBy != 'query') {
                        links.delete(link);
                    }
                });
                d3.selectAll('circle').classed('clicked', false);
                console.log("deleting all linked tickets outside of query");
                console.log("nodeSet size: " + nodeSet.size);
                console.log("querySet size: " + querySet.size);
                console.log("links size: " + links.size);
                console.log("dataset size: " + dataset.size);
                console.log("nodeSet: " + [...nodeSet].toString());

                update();
            });
            
            function update() {

                node = node.data([...dataset], d => d.key);
                node.exit().remove();
                node = node.enter()
                .append('circle')
                .attr('r', getRadiusFromTicketType)
                .attr('fill', getNodeColorFromStatus)
                .attr('stroke', getStrokeColor)
                .attr('stroke-width', 3)
                .merge(node)
                .call(dragDrop)
                .on('mouseover', handleMouseOver)
                .on('mouseout', handleMouseOut)
                .on('click', handleClick);

                nodeLink = nodeLink.data([...links], d => d.source + ' ' + d.target);
                nodeLink.exit().remove();
                nodeLink = nodeLink.enter()
                .append("line")
                .attr("stroke-width", 3)
                .attr("stroke", getLineColorFromLinkType)
                .attr("stroke-dasharray", [5,4])
                .attr("opacity", .8)
                .merge(nodeLink);

                keyLink = keyLink.data([...dataset], d => d.key);
                keyLink.exit().remove();
                keyLink = keyLink.enter()
                .append('a')
                .attr('href', function(d) { return baseUrl + d.key})
                .attr('target', '_blank')
                .append('text')
                .text(node => node.key)
                .attr("font-family", "Helvetica, sans-serif")
                .attr('font-size', 12)
                .attr('font-weight', 'bold')
                .attr('dx', getDxOffsetFromKeyLength)
                .attr('dy', getKeyTextOffsetFromTicketType)
                .style('cursor', 'pointer')
                .merge(keyLink);

                nestedKeyText = svg.selectAll('text');

                simulation.nodes([...dataset])
                simulation.force('link').links([...links]);
                simulation.alpha(.8).restart();                
            }

            function getDxOffsetFromKeyLength(d) {
                return 0 - (d.key.length * 3)
            }
            
            function getKeyTextOffsetFromTicketType(d) {
                if (d.issuetype in NODERADIUS) return NODERADIUS[d.issuetype] + 15;
                else return 25;

            }

            function getRadiusFromTicketType(d) {
                if (d.issuetype in NODERADIUS) return NODERADIUS[d.issuetype];
                else return 10;

            }

            function getRadialForceRadiusFromTicketStatus(d) {
                if (d.status in RADIALFORCERADIUS) return RADIALFORCERADIUS[d.status];
                else return 0;
            }

            function handleClick(d, i) {
                var issuelinks = d.issuelinks;
                var issueAdded = false;
                if (!d3.select(this).classed('clicked') && 'issuelinks' in d) {
                    issuelinks.forEach(issue => {
                        if (!nodeSet.has(issue.key)) {
                            issue['addedBy'] = d.key;
                            issue['x'] = d.x;
                            issue['y'] = d.y;
                            dataset.add(issue);
                            nodeSet.add(issue.key);
                            links.add({
                            'addedBy': d.key,
                            'source': d.key,
                            'target': issue.key,
                            'type': issue.type
                            });
                            issueAdded = true;
                        }
                    });

                    if (issueAdded) {
                        d.fx = d.x;
                        d.fy = d.y;
                    }
                    console.log("adding linked tickets of clicked ticket");
                    console.log("nodeSet size: " + nodeSet.size);
                    console.log("querySet size: " + querySet.size);
                    console.log("links size: " + links.size);
                    console.log("dataset size: " + dataset.size);
                    console.log("nodeSet: " + [...nodeSet].toString());

                }
                else if (d3.select(this).classed('clicked') && 'issuelinks' in d) {
                    console.log("entering delete links control")
                    issuelinks.forEach(issue => {
                        if (!querySet.has(issue.key)) {
                            nodeSet.delete(issue.key);
                        }
                    });
                    
                    dataset.forEach((ticket, j) => {
                        if ('addedBy' in ticket && ticket.addedBy === d.key) {
                            dataset.delete(ticket);
                        }
                    });
                   
                    links.forEach((link, k) => {
                        if ('addedBy' in link && link.addedBy == d.key) {
                            links.delete(link);
                        }
                    });
                    
                    d.fx = null;
                    d.fy = null;

                    console.log("deleting linked tickets of clicked ticket");
                    console.log("nodeSet size: " + nodeSet.size);
                    console.log("querySet size: " + querySet.size);
                    console.log("links size: " + links.size);
                    console.log("dataset size: " + dataset.size);
                    console.log("nodeSet: " + [...nodeSet].toString());
                }

                d3.select(this).classed('clicked', !d3.select(this).classed('clicked'));
                update();
            }
                
            function handleMouseOver(d, i) {
                d3.select(this).attr('fill', 'orange');
                div.transition()        
                    .duration(200)      
                    .style("opacity", .9);      
                div .html("<b>Summary: </b>" + d.summary + "<br/>"  + 
                        "<b>Priority: </b>" + d.priority + "<br/>" + 
                        "<b>Assignee: </b>" + d.assignee + "<br/>" + 
                        "<b>Issuetype: </b>" + d.issuetype + "<br/>" + 
                        "<b>Status: </b>" + d.status)  
                    .style("left", (d3.event.pageX) + "px")     
                    .style("top", (d3.event.pageY - 28) + "px");   
            }

            function handleMouseOut(d, i) {
                d3.select(this).attr('fill', getNodeColorFromStatus);
                div.transition()        
                    .duration(500)      
                    .style("opacity", 0);
            }

            function getStrokeColor(d) {
                if (querySet.has(d.key)) return "black";
                else return getNodeColorFromStatus;
            }

            function getNodeColorFromStatus(node) {
              if (node.status in STATUSCOLORS) return STATUSCOLORS[node.status];
              else return "black";
            }

            function getLineColorFromLinkType(link) {
              if (link.type in LINKCOLORS) return LINKCOLORS[link.type];
              else return "black";    
            }

            function ticked() {
                node
                    .attr('cx', function (node) { return node.x })
                    .attr('cy', function (node) { return node.y });
                nestedKeyText
                    .attr('x', function (node) { return node.x })
                    .attr('y', function (node) { return node.y });
                nodeLink
                    .attr('x1', function (link) { return link.source.x })
                    .attr('y1', function (link) { return link.source.y })
                    .attr('x2', function (link) { return link.target.x })
                    .attr('y2', function (link) { return link.target.y });
            }
        </script>
    </body>
</html>